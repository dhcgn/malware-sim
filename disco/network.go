package disco

import (
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"sync"

	"github.com/dhcgn/malware-sim/catcher"
)

type network struct {
	c *catcher.Catcher
}

// Start implements Disco
func (*network) Start(wg *sync.WaitGroup) {
	defer wg.Done()

	server := []string{}

	ads := getActiveDirectoryServer()
	if ads != "" {
		s, err := getServerFromNetLoginScripts(ads)
		if err == nil {
			server = append(server, s...)
		}
	}

	s, err := getServerFromMountedShares()
	if err == nil {
		server = append(server, s...)
	}
}

func getServerFromMountedShares() (server []string, err error) {
	return server, nil

	// out, err := exec.Command("net", "use").Output()
	// if err != nil {
	// 	return server, err
	// }

}

func getServerFromNetLoginScripts(ads string) (server []string, err error) {
	files, err := getRemoteFiles(fmt.Sprintf(`%s\netlogon`, ads))
	if err != nil {
		return server, err
	}

	for _, f := range files {
		if strings.HasSuffix(f, ".vbs") {
			content, err := getRemoteContent(f)
			if err != nil {
				continue
			}
			s, err := extractServerNamesFromVbs(content)
			if err != nil {
				continue
			}
			server = append(server, s...)
		}
	}

	return server, nil
}

func getActiveDirectoryServer() string {
	return os.Getenv("LOGONSERVER")
}

var regex = regexp.MustCompile(`Const.*=.*"(.*)"`)

func extractServerNamesFromVbs(content string) (server []string, err error) {
	matches := regex.FindAllStringSubmatch(content, -1)
	if len(matches) == 0 {
		return server, fmt.Errorf("no matches found")
	}

	for _, match := range matches {
		server = append(server, match[1])
	}

	return server, nil
}

func getRemoteContent(path string) (content string, err error) {
	if !strings.HasPrefix(path, `\\`) {
		return content, fmt.Errorf("invalid path: %s. Must start with \\\\", path)
	}

	out, err := exec.Command("cmd", "/c", "type", path).Output()
	if err != nil {
		return content, err
	}

	return string(out), err
}

func getRemoteFiles(path string) (files []string, err error) {
	if !strings.HasPrefix(path, `\\`) {
		return files, fmt.Errorf("invalid path: %s. Must start with \\\\", path)
	}

	out, err := exec.Command("cmd", "/c", "dir", path, "/S", "/B").Output()
	if err != nil {
		return files, err
	}

	split := strings.Split(string(out), "\n")
	for _, s := range split {
		s := strings.TrimSpace(s)
		files = append(files, s)
	}

	return files, err
}
